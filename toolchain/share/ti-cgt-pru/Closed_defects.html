
<!-- saved from url=(0099)http://gtjenkins.itg.ti.com:8080/job/JIRA-SDOWP-Generate-Report/551/artifact/jira-query-report.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style>
    table {border-collapse:collapse; table-layout:fixed; width:310px;}
    table td {border: none solid black; width:100px; word-wrap:break-word;}
    th {  background: #eee; }
    </style>
    </head>
    <body>
    <table style="text-align:left; width: 100%; border:1px solid #CCC;border:none;">
    <tbody><tr>
    
    <td align="left">
    <a href="http://www.ti.com/">
    <img alt="" src="data:image/gif;base64,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">
    </a>
    </td>
    </tr>
    <tr><td align="center"><h1>Closed Defects in Release</h1></td></tr>
    </tbody></table>
    <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
    <thead>
    <tr>
    <th align="center">ID</th>
    <th align="center">Summary</th>
    <th align="center">State</th>
    <th align="center">Reported In Release</th>
    <th align="center">Target Release</th>
    <th align="center">Workaround</th>
    <th align="center">Release Notes</th>
    </tr>
    </thead><tbody><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-6289?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-6289</a></td>
        <td>Pointer to VLA 2D array computation in IF condition is double-adjusted and garbled</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.3</td>
        <td>Given "if (p[i][j])", moving the access into a temp with "T = p[i][j]; if (T)" is the simplest workaround.  Since the bug happens early in compilation, optimisation level doesn't matter.



Recasting the IF as a quest/colon, if feasible, is also a workaround.</td>
        <td>A variable-length-array access for an array of at least two dimensions, if used in the predicate of an IF statement, may be mishandled and refer to an incorrect element, possibly outside the array.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-6004?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-6004</a></td>
        <td>OFD erroneously prints 0x&lt;decimal&gt; where hex was intended</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>Update the OFD binary</td>
        <td>When using OFD to view the DWARF debug information in an object file, OFD will incorrectly format what should be a hexadecimal number as 0x followed by the decimal value.  This affects two contexts:  When printing the FORM_ref4 offset of an attribute (such as DW_AT_type) DIE appearing in the same .debug_info section, and when printing the CIE ID.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5943?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5943</a></td>
        <td>Compiler may lose volatile qualifier in A-&gt;B-&gt;C when B and C are both volatile</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>The expression has to contain both dereferences, eg, a-&gt;b-&gt;c, for the problem to appear.  If they're separated by using a temp, as in



  T * volatile p;

  p = a-&gt;b;

  ... p-&gt;c ...



then the problem should be avoided.  Making the temp "p" volatile is also important, to prevent the compiler from recombining the two dereferences.



Or compile with -o1, -o0, or -ooff.</td>
        <td>In an expression like A-&gt;B-&gt;C, when B and C are both volatile structure fields, we'd expect to see two distinct memory accesses every time.  There is a bug in the compiler specifically with having two dereferences in a single expression, ie, A-&gt;B-&gt;C, in which it may lose the volatile qualifier from B.  That may lead it to save A-&gt;B in a temporary variable and reuse that value instead of re-reading it as is supposed to happen.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5905?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5905</a></td>
        <td>Linker command file option --define with pathname with many directory components leads to error: "source line too long"</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5843?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5843</a></td>
        <td>Use of --check_misra=14.10 causes non-MISRA related warning to be emitted</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.3</td>
        <td>No direct workaround.  The warning can be suppressed by the usual methods, or corrected as described in the report.</td>
        <td>If a local variable's address is taken before the variable is initialised, there will usually not be a warning with default settings.  However, if any --check_misra option is used, the compiler will issue a used-before-set warning for the variable.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5791?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5791</a></td>
        <td>C++ enum class with explicit type has some problems</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>Avoid specifying an explicit base type for an enum.</td>
        <td>Values of a C++ enum class type with an explicit base type may not be cast properly to and from integral types.  The exact conditions depend on undefined behavior, and thus are not 100% predictable;  the known cases happen only on Windows, though the compiler uses the same codebase on all platforms.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5674?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5674</a></td>
        <td>Under -o4, compiler may assume a global variable is constant, if it's only set in files containing inline asm()</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>First, compiling with -o3 (or less) instead of -o4 will avoid the problem.



Second, making g_sys_opmode volatile does indeed work around the problem.  Since the "volatile" qualifier tells the compiler that something is modifying the variable outside the compiler's view, that's exactly what is needed to keep it from being assumed constant.



Third, removing the asm() from main.c will work around the problem, by including main.c in the recompilation.  I modified EINT/DINT and EALLOW/EDIS macros in F2806x_Device.h and two cpu.h files, making them use the intrinsics __enable_interrupts, __disable_interrupts, __eallow, and __edis.  As it happens, __enable_interrupts and __disable_interrupts control both INTM and DBGM, while the macros control them individually, so this may not be a completely satisfactory solution.</td>
        <td>The immediate trigger for the bug is that main.c contains asm() statements.  That's the only file that sets g_sys_opmode;  other files only read it.  The presence of asm() keeps the file out of the recompilation that -O4 does.  The compiler, however, still thinks it has the whole program (or at least the important parts);  since it doesn't see main.c, it doesn't see the writes, and concludes that g_sys_opmode is a constant 0.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5623?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5623</a></td>
        <td>Makefile dependence generation (--preproc_dependency) should quote spaces in filenames</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>Rename the files so that they don't have spaces in the names.</td>
        <td>The parser generates makefile dependencies with the --preproc_dependency option.  However, if any filename has a space in its name, the makefile dependencies will not be formatted in a way that can be parsed by make.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5574?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5574</a></td>
        <td>Loop controlled by unsigned char counter iterates more than 255 times</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>Compile at -o1 or less, or restructure the loop to make it not need the 8-bit wraparound.</td>
        <td>A do-while loop with an unsigned loop variable narrower than int can miss one of its wraparound cases, for instance if the loop counts down and the counter starts at zero.  The compiler may promote the variable to int, making it wider than the original and thus it will experience a much larger count when it wraps.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5563?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5563</a></td>
        <td>Checking for MISRA rule 20.1 causes macro redefinition to be ignored</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.3</td>
        <td>None.  To detect redefined macros that aren't predefined, --check_misra=20.1 must not be in the compilation options.</td>
        <td>The --check_misra=20.1 option, which looks for redefined reserved identifiers such as predefined macros, will accidentally suppress warnings about redefinitions of macros that *aren't* predefined.  Since those aren't included in the group that 20.1 tests for, no warning will be issued at all.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5533?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5533</a></td>
        <td>Loop with Cortex-R, -mf3, and DWARF debug leads to assembler error "defined differently in each pass"</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.3</td>
        <td>Several pieces have to come together for this problem to happen.



--opt_for_speed needs to be 3 or greater;  thus a workaround is to reduce optimization to --opt_for_speed=1.



The source code has to have one or more IFs, followed by a nested scope that isn't part of a compound statement and defines local variables, followed by a loop.  Another workaround is thus to move the local variable definitions to the enclosing scope.  (Another that works for the given test case but isn't necessarily general is to initialise all those local variables, where they're defined in the nested scope.)



Normal debug info must be present;  a final workaround is therefore to use --symdebug:none to suppress debug info.  Of course, that makes debugging difficult.</td>
        <td>The assembler will become confused when presented with the sequence of a .align, an instruction that is smaller than the specified alignment, a label, and the DWARF DW_AT_low_pc directive.  Because of the way it processes alignments and labels in different passes, it will conclude that the label was defined with two different values, and report an error.



This sequence is not something a human asm programmer would write.  It arises from compiling a particular shape of statements in a loop, with a particular set of compilation options, to position the label and the .align and the directive.  See the Workaround, which also indicates how to modify the code or compiler options to avoid this bug.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5527?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5527</a></td>
        <td>Local structure initialization is incorrectly optimized away</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>None better than the one given in the description.</td>
        <td>A program that saves the address of a variable in an initialised local struct, but does not use the variable directly, may lose the part of the struct that saves the address.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5511?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5511</a></td>
        <td>Compilers other than C6000 mistakenly support option --legacy</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5236?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5236</a></td>
        <td>Register allocation failure</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>No practical workaround</td>
        <td>The compiler may, in rare cases, allocate registers incorrectly.  The most common symptom would be an internal error indicating that register allocation has failed.  This problem has only been observed on C28x compiler version 8.1.3.LTS, but could occur for other ISAs.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5119?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5119</a></td>
        <td>Using #pragma RETAIN does not keep a static file level variable</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>Use both "#pragma RETAIN" and "__attribute__((used))" at the same time.</td>
        <td>The RETAIN pragma may not keep an unused variable like it's supposed to.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4931?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4931</a></td>
        <td>Applying __attribute__((used)) to static variable does not work</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4926?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4926</a></td>
        <td>Packed structures generate unnecessary code on PRU</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>Don't use the packed attribute for PRU.</td>
        <td>The use of the packed attribute on PRU should not result in any different code since PRU has native unaligned access.  However, unnecessary code is being generated.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4885?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4885</a></td>
        <td>See MISRA diagnostics when compiling stdio.h</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>none</td>
        <td>A program that includes &lt;stdio.h&gt; and checks for MISRA warnings may see some from stdio.h itself, which should not happen.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4832?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4832</a></td>
        <td>Compiler manual mistakenly states #pragma pack is supported</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.0</td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4791?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4791</a></td>
        <td>Structure field reference directly from function call causes INTERNAL ERROR</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>Compile with any value of --opt_level except "off".



Or, given the expression f().x, change it to "t=f(); t.x";  in other word, capture the struct returned from the function call in a variable, and make the field reference from that variable instead of directly from the function call.</td>
        <td>Compiling an expression like f().x -- a function call immediately used to make a structure field reference -- can cause the compiler to abort with INTERNAL ERROR.  Any use of the optimiser, or a simple code rearrangement, avoids the problem.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4700?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4700</a></td>
        <td>Incorrect diagnostic when using macro that comes from macro library</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>Unpack all of the macro libraries and re-pack them into a single unified library, or rename all macros to names with less than 15 characters</td>
        <td>If you are using assembler macro libraries, and you have more than one library, and two or more of those libraries have macros with names that are longer than 15 characters, you may get an incorrect error message from the assembler saying "Bad archive entry"</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4678?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4678</a></td>
        <td>Incorrect error due to typedef of very large object</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.0</td>
        <td>As a workaround, remove the typedef.  Where the typedef was used, instead use the type the typedef refers to.</td>
        <td>The TI compiler infrastructure is incapable of handling user-declared objects above a certain size, because it mistakenly truncates the size of very large objects.  Formerly, this resulted in quiet corruption, which was defect CODEGEN-449.  Now that CODEGEN-449 is fixed, the compiler will emit an error if the user attempts to create a type larger than the tool can handle.  However, this error check is not quite right for typedefs.  A typedef for a very large object that is still within the compiler's limit may cause the parser to mistakenly emit an error that the object is greater than the maximum supported size.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4643?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4643</a></td>
        <td>Documentation incorrectly lists __builtin_sqrt as being supported</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4638?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4638</a></td>
        <td>When shift counts are higher than 32, compiler sometimes optimizes to an incorrect shift count</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>Turn off optimization by using optimization level off.  

Otherwise, avoid a left-shift by a constant as an operand of the listed operations.  However, compiler optimizations could interfere with this.  Try keeping the shift count in a global variable instead of as a literal, or computing the shift separately into a variable (a global or volatile local) and doing the |, +, etc, on the variable.</td>
        <td>Left shifts by 32 or more, as an operand of +, -, &amp;, |, or ^, (eg, ((X&lt;&lt;56) | (Y&lt;&lt;48))) may produce incorrect results.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4634?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4634</a></td>
        <td>Use of stdarg.h va_start macro causes a write to the wrong local variable</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>The test case for codegen-4634 has both a va_list declaration and a use of va_start.  If the two are placed together, by moving the va_list declaration into the scope with the va_start, the problem does not occur.



The general workaround is to ensure an expression appears before the first nested scope.  Exactly how to do that will depend on the situation.</td>
        <td>A function with a nested scope that declares local variables and appears before any expressions in the function, and also declares top-level locals after that, may mishandle the local variables in a way that acts as though some share a location though they're supposed to be distinct.  I.e.,



  int test(int arg, ...)

  {

    { int a = 0; }

    int b;



may mishandle a, b, arg, or any extra arguments.



Known cases all involve the ellipsis (...) parameter, but it is not known if that is also a necessary prerequisite.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4605?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4605</a></td>
        <td>Incompatible redeclaration error with -o4 when using anonymous unions</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>Do not use anonymous structs or unions; give all struct members a name, even if it is never used. </td>
        <td>Anonymous structs and unions are a GCC extension. They are members of a parent structure and have no names. You access the elements inside them as if they were direct members of the parent class. If you have an anonymous struct or union inside a union and you use -O4 optimization, you may get the mistaken error "symbol so-and-so redeclared with incompatible type" at link time.  This bug can only happen in COFF mode.



Essentially the same bug was previously fixed for EABI and was known as CODEGEN-1191.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4600?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4600</a></td>
        <td>Warning when using pragma RETAIN with attribute((noinit))</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.1</td>
        <td> </td>
        <td>When using pragma RETAIN with attribute((noinit)) on the same symbol for an EABI target, a .clink directive is erroneously emitted in the assembly file, leading to a warning that the .CLINK directive is being ignored because the symbol already has .RETAIN specified.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4576?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4576</a></td>
        <td>hex --ascii option truncates address to 16 bits</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>Use the hex converter from an earlier release</td>
        <td>When generating an "ASCII" format hex file, the hex converter would mistakenly truncate addresses to the lower 16 bits.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4419?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4419</a></td>
        <td>Compiler erroneously speculates indexed load from the stack</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>Modify the source code of the offending function to make local variables "volatile."   There's no obvious way to pre-determine that a function will suffer from this bug; you just have to wait for the bug to happen, look at the line number of the offending instruction (which will always be a load with indexed addressing with base register SP), and go to the function at that line number.  Make every local variable in that function "volatile."  If it's a C++ function, you may need to make the function "volatile."</td>
        <td>The compiler moves instructions from one block to another to increase parallelism.  Usually this is done by predicating (adding a condition to) every instruction that is moved above a branch.  However, in some cases, the compiler will "speculate" the instruction, which means removing the condition entirely.  This is done when the instruction's side-effects are judged to be safe, such as load of a local variable.  In the case that the instruction's condition would have been false, this load will be useless, but at least it will be safe, because the stack pointer (SP) is at a legal location, and there won't be a memory fault.  However, when a local variable's value is read with an indexed expression, the index register is not necessarily speculated exactly when the load is, so the index register may have a garbage value.  In this test case, the load was speculated, but the index register definition wasn't, so in the false branch, the computed address was garbage, and we would read a random memory address, causing a memory fault.  (Even though SP was perfectly valid, the index register was garbage, so SP+index might point anywhere in memory.)</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4407?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4407</a></td>
        <td>Not using const causes unexpected build error when calling std::sort</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>Remove unnecessary const from helper in s__algo.c</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4182?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4182</a></td>
        <td>Should ignore option --pending_instantiations when compiling C files</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>If the user wishes to use the option --pending_instantiations, they must add this option individually to each C++ file.</td>
        <td>The compiler option --pending_instantiations only makes any sense when used with C++ code.  It cannot have any effect on C code.  Indeed, when passed as an option to a compilation of C code, the compiler will stop and emit an error, "pending instantiations option can be used only when compiling C++"  



This is troublesome when trying to compile a mixture of C and C++ files in CCS.  If the user wishes to use the option --pending_instantiations, they cannot just add this option to the global compiler options list; they must add this option individually to each C++ file.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4180?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4180</a></td>
        <td>PRU compiler fails to account for zero-sized struct passed in register as function argument</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td> </td>
        <td>If an empty struct is passed as a function argument, the caller function passes 0 in a register but the called function ignores the argument.  This results in the subsequent argument being allocated to a different register than the one the caller used.  Now, both caller and callee functions ignore zero-sized struct arguments.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4178?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4178</a></td>
        <td>Update PRU documentation to include that 24-bit structs are also passed in registers</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4113?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4113</a></td>
        <td>Assembler computes wrong result for expression 0x232800 % 0x10000</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>In some instances, as in the original test case, the AND operator can be used instead, but that is not a general workaround.</td>
        <td>The modulo operator in the TI assembler, for releases made in mid-to-late 2016 and all of 2017, is unreliable.  In some cases it will produce an incorrect answer.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4078?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4078</a></td>
        <td>Linker takes over 5 minutes to finish</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>None.  If the linker command file wants to be that specific about memory ranges, then the work has to be done, and the option to disable the work has its own bug.</td>
        <td>Linking may take excessively long when the linker command file specifically places a lot of variables at specific addresses, especially for C2000.  The original report was placing more than 300 variables.  The --no_placement_optimization option is not a workaround because it causes a linker crash.  Both problems are fixed together.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3931?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3931</a></td>
        <td>Compiler crashes while handling 0 length array in zero sized struct</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>None</td>
        <td>The compiler crashes while parsing a struct or class with zero-sized members in C++ mode.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3923?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3923</a></td>
        <td>DWARF CFI information lost due to microoptimizations</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>No practical workaround.</td>
        <td>Some optimizations in the compiler would change instructions but fail to retain debugging directives attached to those instructions.  This could impact the accuracy of the DWARF debugging information in various ways.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3918?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3918</a></td>
        <td>Writing multiple input sections in one line unexpectedly changes how input sections are combined into output sections</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>Stick with separate lines, if there are subsection cases like this one that should be comprehended.</td>
        <td>In a linker command file, using a line like "hello.obj (.const, .far)" may link differently  than two lines with one section each.  The problem is that the single line is interpreted as the OR of the two sections, and the linker does not understand that the OR also encompasses any of their subsections.  Two separate lines are analysed separately and completely.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3794?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3794</a></td>
        <td>False warning for MISRA 10.1/10.2 when commutative binary operands swapped</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td> </td>
        <td>In certain cases, the compiler could emit an unwarranted MISRA diagnostic about type conversion. This would occur when using a commutative binary arithmetic operator with mixed operand types.  The compiler mistakenly compared one operand's type to the other type.  It should have compared each type to the promoted type of the operation.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3595?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3595</a></td>
        <td>Stack usage under reports stack amount used because it fails to handle function aliases</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td> </td>
        <td>CCS Stack Assistant did not accurately track aliased functions-- functions whose definitions are represented by a different symbol name.  Now, the alias function will be used to determine stack size correctly, and the aliased function call name will be replaced with its alias.  Currently, the Stack Assistant GUI is not capable of showing both the aliased and alias function names for calls to aliased functions-- this will require a future update.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00052006?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00052006</a></td>
        <td>ltoa definition conflicts with quasi-standard ltoa</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>Don't use ltoa; instead use sprintf.</td>
        <td>For a long time, the TI RTS has defined a function named ltoa used in printf.  However, quasi-standard function ltoa with a different prototype has been floating around the net for even longer.  The presence of TI's definition causes problems for applications which attempt to use ltoa.  It's difficult for the user to override the definition in their program to use the quasi-standard version, because TI has a prototype for the bogus version in stdlib.h



This defect has been resolved by renaming TI's ltoa to something in the implementation namespace.  Additionally, we've added a definition of ltoa conforming to the quasi-standard version.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00050131?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00050131</a></td>
        <td>Local struct with non-constant initializer treated as static scope variable</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.2</td>
        <td>Completely specify every aggregate member in the initializer, or do not provide an initializer at all and instead populate each field with a statement.</td>
        <td>Function local non-static aggregate (array or struct) variables which are initialized to zero, or with an initializer that incompletely specifies all of the aggregate members, will be converted to static scope (global) objects.  This is wrong; each time the function is entered, there should be a fresh copy of the variable.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00043877?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00043877</a></td>
        <td>Emit error message when objects too large for infrastructure (roughly 512MiB, or 256MiWords) are truncated</td>
        <td>Fixed</td>
        <td></td>
        <td>PRU_2.3.0</td>
        <td>N/A</td>
        <td>Due to an internal limitation, the code generation tools cannot presently allocate objects larger than roughly 512MiB (roughly 256MiWords). Data objects larger than this are silently truncated to a much smaller size.  When such objects are declared in the code, they are silently truncated and compilation continues without any diagnostics.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00014430?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00014430</a></td>
        <td>calloc doesn't check arguments to make sure the requested size is reasonable</td>
        <td>Fixed</td>
        <td>PRU_2.3.0</td>
        <td>PRU_2.3.0</td>
        <td> </td>
        <td> </td>
        </tr></tbody></table>
    <br>
    <b>Generated on Thu Oct 31 15:36:59 2019 </b>
    
    </body></html>